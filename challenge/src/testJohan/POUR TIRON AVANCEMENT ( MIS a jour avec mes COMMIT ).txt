Fonctionnement de mon programme :

Creé aleatoirement une solution valide, cherche tous les voisins de cette solution , les évalues.
Si un voisins est meilleurs, on le selectionne et on cherche ces voisins ...

Liste tabou de base implémenté, probleme rencontrer : il n'est pas rare que tous les "voisins" 
sont des solution qui on une capacité trop grande ou tabou.

Solution trouvé : Creation d'une liste de voisin, si tous les voisins sont evaluate a -1 ou TABOU, alors on prend aleatoirement un voisin

Resultat , l'algo trouve la solution optimale en moin de 100 iteration ! ( le plus souvent ... )

Fonction ajouté : le nombre de batch est "trouvé" par l'application <- fonctionne pas pour les nb de produits

Resultat sur les fichier avec les bon temps d'execution mais durée tabou fixe:
Fichier		MeilleurResDmonAlgo		resultat donné par le prof
005			215						215
007a		2581					2581
007			245						245
020a		200						200 
050a		250						250    ( Trouvé des la solution initial :p )
100a		135132 (1 seul test)  	49 392  
200a		509867 (1 seul test		323 955



Abandonné ^^', j'ai essayé de faire une solution initial ( init2() )qui donne directement une tres bonne solution , sa marcche pour les instance
005 et 007, mais c'est beaucoup trop incompréhensible !

Fait initMinimizeBatch() -> j'ai amelioré la fonction an la remplacant pour l'instant par une fonction initMinimizeBatch()
qui donne le vrai nombre de batch mini.
Le probleme maintenant pour les grand nombre d'objet, c'est que ma recherche de voisin est beaucoup trop gourmande ! du coup sa fait a peine 
100 iteration :D

à faire : faire evoluer la durée tabou 

Réglage auto-adaptatif de la longueur de la liste taboue
 technique consiste à laisser la longueur de la liste taboue se régler
elle-même au cours de la recherche :
- Si on observe que l’algorithme tend à cycler (ou tend à rester confiné dans la
même région), on augmente la longueur de la liste
- Sinon on la réduit légèrement