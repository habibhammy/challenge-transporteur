Fonctionnement de mon programme :

Creé aleatoirement une solution valide, cherche tous les voisins de cette solution , les évalues.
Si un voisins est meilleurs, on le selectionne et on cherche ces voisins ...

Liste tabou de base implémenté, probleme rencontrer : il n'est pas rare que tous les "voisins" 
sont des solution qui on une capacité trop grande ou tabou.

Solution trouvé : Creation d'une liste de voisin, si tous les voisins sont evaluate a -1 ou TABOU, alors on prend aleatoirement un voisin

Resultat , l'algo trouve la solution optimale en moin de 100 iteration ! ( le plus souvent ... )

Fonction ajouté : le nombre de batch est "trouvé" par l'application <- fonctionne pas pour les nb de produits

Resultat sur les fichier avec les bon temps d'execution mais durée tabou fixe:
Fichier		MeilleurResDmonAlgo		resultat donné par le prof
005			215						215
007a		2581					2581
007			245						245
020a		200						200 
050a		280						250    < probleme
100a		135132 (1 seul test)  	49 392  
200a		509867 (1 seul test		323 955



Abandonné ^^', j'ai essayé de faire une solution initial ( init2() )qui donne directement une tres bonne solution , sa marcche pour les instance
005 et 007, mais c'est beaucoup trop incompréhensible !

Fait initMinimizeBatch() -> AMELIORATION : Son on veut minimiser juste le nombre de voyage , sa revient pas juste au probleme du sac à dos ?
La meilleur solution est de faire une solution initiale (valide...) qui Minimise le nombre de batch! comme ça on a juste a explorer pour ce 
nombre de batch et les nombres plus grand !

à faire : faire evoluer la durée tabou 

Réglage auto-adaptatif de la longueur de la liste taboue
 technique consiste à laisser la longueur de la liste taboue se régler
elle-même au cours de la recherche :
- Si on observe que l’algorithme tend à cycler (ou tend à rester confiné dans la
même région), on augmente la longueur de la liste
- Sinon on la réduit légèrement